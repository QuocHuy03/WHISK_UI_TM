import requests
import json
import pandas as pd
import uuid
import base64
import os
from datetime import datetime
from colorama import init, Fore, Style
from tqdm import tqdm
import threading
import time
import sys
import random
import string
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry
import tkinter as tk
from tkinter import filedialog
from concurrent.futures import ThreadPoolExecutor, as_completed
import queue

from auth.auth_guard import check_key_online
API_URL = "http://62.171.131.164:5000"

# Kh·ªüi t·∫°o colorama
init(autoreset=True)

# ===== LOGGING CONFIGURATION =====
class LogConfig:
    """C·∫•u h√¨nh logging - c√≥ th·ªÉ b·∫≠t/t·∫Øt c√°c lo·∫°i log"""
    DEBUG = False  # B·∫≠t/t·∫Øt log debug chi ti·∫øt
    INFO = True    # B·∫≠t/t·∫Øt log th√¥ng tin
    SUCCESS = True # B·∫≠t/t·∫Øt log th√†nh c√¥ng
    ERROR = True   # B·∫≠t/t·∫Øt log l·ªói (lu√¥n hi·ªÉn th·ªã)
    WARNING = True # B·∫≠t/t·∫Øt log c·∫£nh b√°o

# Kh·ªüi t·∫°o c·∫•u h√¨nh log
log_config = LogConfig()

# Thread-safe variables
log_lock = threading.Lock()
progress_lock = threading.Lock()
seed_lock = threading.Lock()
current_seed = 0  # Global seed counter for multi-threading

# ===== BROWSER SIMULATION SETTINGS =====
class BrowserSimulator:
    """L·ªõp gi·∫£ l·∫≠p tr√¨nh duy·ªát th·∫≠t"""
    
    def __init__(self):
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Edge/120.0.0.0 Safari/537.36"
        ]
        self.session = requests.Session()
        self.proxy_config = None
        self._setup_session()
    
    def _setup_session(self):
        """Thi·∫øt l·∫≠p session v·ªõi retry strategy"""
        retry_strategy = Retry(
            total=3,
            backoff_factor=1,
            status_forcelist=[429, 500, 502, 503, 504],
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
    
    def set_proxy(self, proxy_config):
        """Thi·∫øt l·∫≠p proxy cho session"""
        self.proxy_config = proxy_config
        if proxy_config:
            self.session.proxies.update(proxy_config)
            log_success("ƒê√£ thi·∫øt l·∫≠p proxy th√†nh c√¥ng")
        else:
            self.session.proxies.clear()
            log_info("ƒê√£ x√≥a c·∫•u h√¨nh proxy")
    
    def get_random_user_agent(self):
        """L·∫•y User-Agent ng·∫´u nhi√™n"""
        return random.choice(self.user_agents)
    
    def get_browser_headers(self):
        """T·∫°o headers gi·∫£ l·∫≠p tr√¨nh duy·ªát th·∫≠t"""
        user_agent = self.get_random_user_agent()
        
        headers = {
            "User-Agent": user_agent,
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
            "Accept-Language": "en-US,en;q=0.9,vi;q=0.8",
            "Accept-Encoding": "gzip, deflate, br",
            "DNT": "1",
            "Connection": "keep-alive",
            "Upgrade-Insecure-Requests": "1",
            "Sec-Fetch-Dest": "document",
            "Sec-Fetch-Mode": "navigate",
            "Sec-Fetch-Site": "none",
            "Sec-Fetch-User": "?1",
            "Cache-Control": "max-age=0",
            "sec-ch-ua": '"Not_A Brand";v="8", "Chromium";v="120", "Google Chrome";v="120"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": '"Windows"'
        }
        return headers
    
    def get_api_headers(self, access_token=None, cookie=None):
        """T·∫°o headers cho API requests"""
        headers = self.get_browser_headers()
        headers.update({
            "Content-Type": "application/json",
            "X-Requested-With": "XMLHttpRequest",
            "Origin": "https://labs.google",
            "Referer": "https://labs.google/"
        })
        
        if access_token:
            headers["Authorization"] = f"Bearer {access_token}"
        if cookie:
            headers["Cookie"] = cookie
            
        return headers
    
    def generate_fingerprint(self):
        """T·∫°o fingerprint gi·∫£ l·∫≠p"""
        fingerprint = {
            "screen_resolution": random.choice(["1920x1080", "1366x768", "1440x900", "1536x864"]),
            "timezone": random.choice(["Asia/Ho_Chi_Minh", "Asia/Bangkok", "Asia/Jakarta"]),
            "language": "en-US",
            "platform": "Win32",
            "hardware_concurrency": random.choice([4, 8, 12, 16]),
            "device_memory": random.choice([4, 8, 16, 32])
        }
        return fingerprint
    
    def random_delay(self, min_delay=1, max_delay=3):
        """Delay ng·∫´u nhi√™n gi·ªØa c√°c request"""
        delay = random.uniform(min_delay, max_delay)
        time.sleep(delay)
        return delay
    
    def make_request(self, method, url, **kwargs):
        """Th·ª±c hi·ªán request v·ªõi gi·∫£ l·∫≠p tr√¨nh duy·ªát"""
        # Th√™m headers gi·∫£ l·∫≠p
        if 'headers' not in kwargs:
            kwargs['headers'] = {}
        
        # Merge v·ªõi headers gi·∫£ l·∫≠p
        browser_headers = self.get_browser_headers()
        kwargs['headers'].update(browser_headers)
        
        # Th√™m proxy n·∫øu c√≥
        if self.proxy_config:
            kwargs['proxies'] = self.proxy_config
        
        # Random delay tr∆∞·ªõc request
        delay = self.random_delay()
        
        try:
            log_debug(f"üîç make_request:")
            log_debug(f"  - Method: {method}")
            log_debug(f"  - URL: {url}")
            log_debug(f"  - Headers: {kwargs.get('headers', {})}")
            log_debug(f"  - Proxies: {kwargs.get('proxies', 'None')}")
            log_debug(f"  - Timeout: {kwargs.get('timeout', 'None')}")
            
            response = self.session.request(method, url, **kwargs)
            
            log_debug(f"üîç make_request response:")
            log_debug(f"  - Status: {response.status_code if response else 'None'}")
            log_debug(f"  - Response object: {type(response)}")
            
            # Ki·ªÉm tra response c√≥ h·ª£p l·ªá kh√¥ng
            if response is None:
                log_error("Response l√† None - kh√¥ng c√≥ ph·∫£n h·ªìi t·ª´ server")
                return None
            
            # Log th√™m th√¥ng tin response
            log_debug(f"  - Response headers: {dict(response.headers)}")
            log_debug(f"  - Response text length: {len(response.text) if response.text else 0}")
            
            return response
            
        except requests.exceptions.ProxyError as e:
            log_error(f"L·ªói proxy: {e}")
            log_error("Ki·ªÉm tra l·∫°i c·∫•u h√¨nh proxy trong proxy.txt")
            return None
        except requests.exceptions.Timeout as e:
            log_error(f"Request timeout: {e}")
            log_error("Th·ª≠ tƒÉng timeout ho·∫∑c ki·ªÉm tra k·∫øt n·ªëi m·∫°ng")
            return None
        except requests.exceptions.ConnectionError as e:
            log_error(f"L·ªói k·∫øt n·ªëi: {e}")
            log_error("Ki·ªÉm tra k·∫øt n·ªëi internet v√† proxy")
            return None
        except requests.exceptions.RequestException as e:
            log_error(f"L·ªói request: {e}")
            return None
        except Exception as e:
            log_error(f"L·ªói kh√¥ng x√°c ƒë·ªãnh: {e}")
            import traceback
            log_error(f"Chi ti·∫øt l·ªói: {traceback.format_exc()}")
            return None

# Kh·ªüi t·∫°o browser simulator
browser_sim = BrowserSimulator()

def activate_browser_simulation():
    """K√≠ch ho·∫°t c√°c th√¥ng s·ªë gi·∫£ l·∫≠p tr√¨nh duy·ªát th·∫≠t"""
    print("‚úì ƒê√£ k√≠ch ho·∫°t c√°c th√¥ng s·ªë gi·∫£ l·∫≠p tr√¨nh duy·ªát th·∫≠t:")
    print("  - User-Agent ng·∫´u nhi√™n")
    print("  - Headers gi·∫£ l·∫≠p tr√¨nh duy·ªát")
    print("  - Fingerprint gi·∫£ l·∫≠p")
    print("  - Retry strategy cho request")
    print("  - Connection pooling")

def log_debug(message):
    """Log debug chi ti·∫øt - ch·ªâ hi·ªÉn th·ªã khi DEBUG = True"""
    if log_config.DEBUG:
        with log_lock:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            print(f"{Fore.CYAN}[{timestamp}] {Fore.BLUE}[DEBUG]{Style.RESET_ALL} {message}")

def log_info(message):
    """Log th√¥ng tin v·ªõi th·ªùi gian v√† m√†u xanh"""
    if log_config.INFO:
        with log_lock:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            print(f"{Fore.CYAN}[{timestamp}] {Fore.GREEN}[INFO]{Style.RESET_ALL} {message}")

def log_success(message):
    """Log th√†nh c√¥ng v·ªõi th·ªùi gian v√† m√†u xanh l√°"""
    if log_config.SUCCESS:
        with log_lock:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            print(f"{Fore.CYAN}[{timestamp}] {Fore.GREEN}[SUCCESS]{Style.RESET_ALL} {message}")

def log_error(message):
    """Log l·ªói v·ªõi th·ªùi gian v√† m√†u ƒë·ªè - lu√¥n hi·ªÉn th·ªã"""
    with log_lock:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"{Fore.CYAN}[{timestamp}] {Fore.RED}[ERROR]{Style.RESET_ALL} {message}")

def log_warning(message):
    """Log c·∫£nh b√°o v·ªõi th·ªùi gian v√† m√†u v√†ng"""
    if log_config.WARNING:
        with log_lock:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            print(f"{Fore.CYAN}[{timestamp}] {Fore.YELLOW}[WARNING]{Style.RESET_ALL} {message}")

def log_user_info(name, email):
    """Log th√¥ng tin user v·ªõi m√†u ƒë·∫∑c bi·ªát"""
    with log_lock:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"{Fore.CYAN}[{timestamp}] {Fore.MAGENTA}[USER]{Style.RESET_ALL} {Fore.BLUE}{name}{Style.RESET_ALL} <{Fore.CYAN}{email}{Style.RESET_ALL}>")

class LoadingSpinner:
    """Loading spinner v·ªõi animation"""
    def __init__(self, message="Loading...", color=Fore.YELLOW):
        self.message = message
        self.color = color
        self.spinner_chars = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è']
        self.running = False
        self.thread = None
    
    def start(self):
        """B·∫Øt ƒë·∫ßu spinner"""
        self.running = True
        self.thread = threading.Thread(target=self._spin)
        self.thread.daemon = True
        self.thread.start()
    
    def stop(self):
        """D·ª´ng spinner"""
        self.running = False
        if self.thread:
            self.thread.join()
        # X√≥a d√≤ng hi·ªán t·∫°i
        sys.stdout.write('\r' + ' ' * (len(self.message) + 10) + '\r')
        sys.stdout.flush()
    
    def _spin(self):
        """Animation loop"""
        i = 0
        while self.running:
            sys.stdout.write(f'\r{self.color}{self.spinner_chars[i % len(self.spinner_chars)]}{Style.RESET_ALL} {self.message}')
            sys.stdout.flush()
            time.sleep(0.1)
            i += 1

def show_loading(message, duration=2):
    """Hi·ªÉn th·ªã loading v·ªõi th·ªùi gian c·ªë ƒë·ªãnh"""
    spinner = LoadingSpinner(message, Fore.CYAN)
    spinner.start()
    time.sleep(duration)
    spinner.stop()

def get_thread_count():
    """L·∫•y s·ªë lu·ªìng t·ª´ user input"""
    print(f"\n{Fore.YELLOW}üßµ C·∫•u h√¨nh s·ªë lu·ªìng:{Style.RESET_ALL}")
    print(f"{Fore.CYAN}L∆∞u √Ω:{Style.RESET_ALL} S·ªë lu·ªìng cao h∆°n s·∫Ω t·∫°o ·∫£nh nhanh h∆°n nh∆∞ng c√≥ th·ªÉ g√¢y qu√° t·∫£i server")
    print(f"{Fore.CYAN}Khuy·∫øn ngh·ªã:{Style.RESET_ALL} 2-5 lu·ªìng cho hi·ªáu su·∫•t t·ªëi ∆∞u")
    
    while True:
        try:
            thread_input = input(f"\n{Fore.GREEN}Nh·∫≠p s·ªë lu·ªìng (1-10, m·∫∑c ƒë·ªãnh 3): {Style.RESET_ALL}").strip()
            
            if not thread_input:
                return 3  # M·∫∑c ƒë·ªãnh 3 lu·ªìng
            
            thread_count = int(thread_input)
            
            if 1 <= thread_count <= 10:
                log_success(f"ƒê√£ ch·ªçn {thread_count} lu·ªìng")
                return thread_count
            else:
                print(f"{Fore.RED}S·ªë lu·ªìng ph·∫£i t·ª´ 1 ƒë·∫øn 10!{Style.RESET_ALL}")
        except ValueError:
            print(f"{Fore.RED}Vui l√≤ng nh·∫≠p s·ªë nguy√™n h·ª£p l·ªá!{Style.RESET_ALL}")

def get_output_folder():
    """L·∫•y folder output t·ª´ user input"""
    print(f"\n{Fore.YELLOW}üìÅ Ch·ªçn folder ƒë·ªÉ l∆∞u ·∫£nh:{Style.RESET_ALL}")
    print(f"{Fore.CYAN}1.{Style.RESET_ALL} S·ª≠ d·ª•ng folder hi·ªán t·∫°i (./)")
    print(f"{Fore.CYAN}2.{Style.RESET_ALL} T·∫°o folder m·ªõi")
    print(f"{Fore.CYAN}3.{Style.RESET_ALL} Nh·∫≠p ƒë∆∞·ªùng d·∫´n folder")
    
    while True:
        choice = input(f"\n{Fore.GREEN}Ch·ªçn (1/2/3): {Style.RESET_ALL}").strip()
        
        if choice == "1":
            return "./"
        elif choice == "2":
            folder_name = input(f"{Fore.GREEN}Nh·∫≠p t√™n folder m·ªõi: {Style.RESET_ALL}").strip()
            if not folder_name:
                folder_name = f"images_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            return folder_name
        elif choice == "3":
            folder_path = input(f"{Fore.GREEN}Nh·∫≠p ƒë∆∞·ªùng d·∫´n folder: {Style.RESET_ALL}").strip()
            return folder_path
        else:
            print(f"{Fore.RED}L·ª±a ch·ªçn kh√¥ng h·ª£p l·ªá! Vui l√≤ng ch·ªçn 1, 2 ho·∫∑c 3.{Style.RESET_ALL}")

def create_folder_if_not_exists(folder_path):
    """T·∫°o folder n·∫øu ch∆∞a t·ªìn t·∫°i"""
    if not os.path.exists(folder_path):
        try:
            os.makedirs(folder_path, exist_ok=True)
            log_success(f"ƒê√£ t·∫°o folder: {folder_path}")
            return True
        except Exception as e:
            log_error(f"Kh√¥ng th·ªÉ t·∫°o folder {folder_path}: {e}")
            return False
    else:
        log_info(f"Folder ƒë√£ t·ªìn t·∫°i: {folder_path}")
        return True

def read_cookie():
    """ƒê·ªçc cookie t·ª´ file cookie.txt"""
    with open('cookie.txt', 'r', encoding='utf-8') as f:
        return f.read().strip()

def read_proxy():
    """ƒê·ªçc proxy t·ª´ file proxy.txt"""
    try:
        with open('proxy.txt', 'r', encoding='utf-8') as f:
            proxy_line = f.read().strip()
            if not proxy_line:
                return None
            
            # Format: ip:port:username:password
            parts = proxy_line.split(':')
            if len(parts) == 4:
                ip, port, username, password = parts
                proxy_url = f"http://{username}:{password}@{ip}:{port}"
                return {
                    'http': proxy_url,
                    'https': proxy_url
                }
            else:
                log_error("Format proxy kh√¥ng ƒë√∫ng. C·∫ßn: ip:port:username:password")
                return None
    except FileNotFoundError:
        log_warning("Kh√¥ng t√¨m th·∫•y file proxy.txt")
        return None
    except Exception as e:
        log_error(f"L·ªói khi ƒë·ªçc proxy: {e}")
        return None

def test_proxy_connection(proxy_config):
    """Test k·∫øt n·ªëi proxy"""
    if not proxy_config:
        log_info("Kh√¥ng c√≥ proxy ƒë·ªÉ test")
        return True
    
    log_info("üîç ƒêang test k·∫øt n·ªëi proxy...")
    test_urls = [
        "http://httpbin.org/ip",
        "https://httpbin.org/ip",
        "https://www.google.com"
    ]
    
    for url in test_urls:
        try:
            log_info(f"  - Test URL: {url}")
            response = requests.get(url, proxies=proxy_config, timeout=10)
            if response.status_code == 200:
                log_success(f"  ‚úì Proxy ho·∫°t ƒë·ªông v·ªõi {url}")
                if "httpbin.org" in url:
                    log_info(f"    IP hi·ªán t·∫°i: {response.json().get('origin', 'Unknown')}")
                return True
            else:
                log_warning(f"  ‚ö† Proxy tr·∫£ v·ªÅ status {response.status_code} v·ªõi {url}")
        except requests.exceptions.ProxyError as e:
            log_error(f"  ‚úó L·ªói proxy v·ªõi {url}: {e}")
        except requests.exceptions.Timeout as e:
            log_error(f"  ‚úó Timeout v·ªõi {url}: {e}")
        except Exception as e:
            log_error(f"  ‚úó L·ªói kh√°c v·ªõi {url}: {e}")
    
    log_error("Proxy kh√¥ng ho·∫°t ƒë·ªông v·ªõi b·∫•t k·ª≥ URL n√†o")
    return False

def get_access_token(cookie):
    """L·∫•y access_token t·ª´ Google Labs API"""
    url = "https://labs.google/fx/api/auth/session"
    headers = browser_sim.get_api_headers(cookie=cookie)
    
    # Hi·ªÉn th·ªã loading spinner
    spinner = LoadingSpinner("ƒêang x√°c th·ª±c v·ªõi Google Labs...", Fore.CYAN)
    spinner.start()
    
    try:
        response = browser_sim.make_request("GET", url, headers=headers, timeout=30)
        spinner.stop()
        
        if response and response.status_code == 200:
            return response.json()
        else:
            if response:
                log_error(f"L·ªói khi l·∫•y access_token: {response.status_code}")
                log_error(response.text)
            return None
    except requests.exceptions.Timeout:
        spinner.stop()
        log_error("Timeout khi k·∫øt n·ªëi ƒë·∫øn Google Labs")
        return None
    except Exception as e:
        spinner.stop()
        log_error(f"L·ªói k·∫øt n·ªëi: {e}")
        return None

def read_excel_data(excel_file_path='prompt_image.xlsx'):
    """ƒê·ªçc d·ªØ li·ªáu t·ª´ file Excel (STT, PROMPT)"""
    try:
        df = pd.read_excel(excel_file_path)
        stt_list = df.iloc[:, 0].tolist()  # C·ªôt A
        prompt_list = df.iloc[:, 1].tolist()  # C·ªôt B
        return list(zip(stt_list, prompt_list))
    except Exception as e:
        log_error(f"L·ªói khi ƒë·ªçc file Excel: {e}")
        return []

def read_excel_img2img_data(excel_file_path='prompt_image.xlsx'):
    """ƒê·ªçc d·ªØ li·ªáu t·ª´ file Excel cho Image-to-Image (STT, PROMPT, IMAGE_PATH)"""
    try:
        df = pd.read_excel(excel_file_path)
        stt_list = df.iloc[:, 0].tolist()  # C·ªôt A
        prompt_list = df.iloc[:, 1].tolist()  # C·ªôt B
        image_path_list = df.iloc[:, 2].tolist()  # C·ªôt C
        return list(zip(stt_list, prompt_list, image_path_list))
    except Exception as e:
        log_error(f"L·ªói khi ƒë·ªçc file Excel: {e}")
        return []

def generate_image(access_token, prompt, seed, aspect_ratio="IMAGE_ASPECT_RATIO_LANDSCAPE", max_retries=3):
    """G·ªçi API ƒë·ªÉ t·∫°o ·∫£nh v·ªõi c∆° ch·∫ø retry"""
    url = "https://aisandbox-pa.googleapis.com/v1/whisk:generateImage"
    
    headers = browser_sim.get_api_headers(access_token=access_token)
    
    # C√°c th√¥ng s·ªë c·ªë ƒë·ªãnh
    image_model = "IMAGEN_3_5"
    
    for attempt in range(max_retries):
        # T·∫°o UUID ng·∫´u nhi√™n cho workflowId m·ªói l·∫ßn retry
        workflow_id = str(uuid.uuid4())
        
        payload = {
            "clientContext": {
                "workflowId": workflow_id,
                "tool": "BACKBONE",
                "sessionId": f";{uuid.uuid4().int}"
            },
            "imageModelSettings": {
                "imageModel": image_model,
                "aspectRatio": aspect_ratio
            },
            "seed": seed,
            "prompt": prompt,
            "mediaCategory": "MEDIA_CATEGORY_BOARD"
        }
        
        # Hi·ªÉn th·ªã loading spinner
        if attempt == 0:
            spinner = LoadingSpinner("ƒêang t·∫°o ·∫£nh v·ªõi AI...", Fore.MAGENTA)
        else:
            spinner = LoadingSpinner(f"ƒêang t·∫°o ·∫£nh v·ªõi AI... (Th·ª≠ l·∫°i l·∫ßn {attempt + 1})", Fore.MAGENTA)
        spinner.start()
        
        try:
            if attempt > 0:
                log_info(f"üîÑ Th·ª≠ l·∫°i l·∫ßn {attempt + 1}/{max_retries}")
                # Delay tr∆∞·ªõc khi retry
                time.sleep(2 * attempt)
            
            log_debug(f"üîç ƒêang g·ªçi API generate_image:")
            log_debug(f"  - URL: {url}")
            log_debug(f"  - Payload: {json.dumps(payload, indent=2)}")
            
            response = browser_sim.make_request("POST", url, headers=headers, json=payload, timeout=60)
            spinner.stop()
            
            if response is None:
                log_error("API tr·∫£ v·ªÅ None - kh√¥ng c√≥ k·∫øt qu·∫£")
                if attempt < max_retries - 1:
                    log_warning(f"S·∫Ω th·ª≠ l·∫°i sau {2 * (attempt + 1)} gi√¢y...")
                    continue
                else:
                    log_error("C√≥ th·ªÉ do:")
                    log_error("  - Proxy kh√¥ng ho·∫°t ƒë·ªông")
                    log_error("  - K·∫øt n·ªëi m·∫°ng b·ªã l·ªói")
                    log_error("  - Server Google Labs kh√¥ng ph·∫£n h·ªìi")
                    log_error("  - Access token h·∫øt h·∫°n")
                    return None
            
            log_debug(f"üîç API response:")
            log_debug(f"  - Status code: {response.status_code}")
            log_debug(f"  - Headers: {dict(response.headers)}")
            log_debug(f"  - Response text: {response.text[:500]}...")  # Ch·ªâ in 500 k√Ω t·ª± ƒë·∫ßu
            
            if response.status_code == 200:
                try:
                    result = response.json()
                    log_debug(f"üîç JSON response:")
                    log_debug(f"  - Response keys: {list(result.keys()) if result else 'None'}")
                    if 'imagePanels' in result:
                        log_debug(f"  - imagePanels count: {len(result['imagePanels'])}")
                        for i, panel in enumerate(result['imagePanels']):
                            log_debug(f"    Panel {i} keys: {list(panel.keys())}")
                            if 'generatedImages' in panel:
                                log_debug(f"    Panel {i} generatedImages count: {len(panel['generatedImages'])}")
                                for j, img in enumerate(panel['generatedImages']):
                                    log_debug(f"      Image {j} keys: {list(img.keys())}")
                    return result
                except Exception as json_error:
                    log_error(f"L·ªói parse JSON: {json_error}")
                    log_error(f"Response text g·ªëc: {response.text}")
                    if attempt < max_retries - 1:
                        log_warning(f"S·∫Ω th·ª≠ l·∫°i sau {2 * (attempt + 1)} gi√¢y...")
                        continue
                    return None
            elif response.status_code == 401:
                log_error("L·ªói x√°c th·ª±c (401) - Access token c√≥ th·ªÉ ƒë√£ h·∫øt h·∫°n")
                log_error("Vui l√≤ng c·∫≠p nh·∫≠t cookie.txt")
                return None
            elif response.status_code == 403:
                log_error("L·ªói quy·ªÅn truy c·∫≠p (403) - C√≥ th·ªÉ b·ªã ch·∫∑n b·ªüi Google")
                if attempt < max_retries - 1:
                    log_warning("Th·ª≠ ƒë·ªïi proxy ho·∫∑c User-Agent v√† th·ª≠ l·∫°i...")
                    continue
                else:
                    log_error("Th·ª≠ ƒë·ªïi proxy ho·∫∑c User-Agent")
                    return None
            elif response.status_code == 429:
                log_error("Qu√° nhi·ªÅu request (429) - B·ªã rate limit")
                if attempt < max_retries - 1:
                    wait_time = 5 * (attempt + 1)
                    log_warning(f"Ch·ªù {wait_time} gi√¢y r·ªìi th·ª≠ l·∫°i...")
                    time.sleep(wait_time)
                    continue
                else:
                    log_error("Ch·ªù m·ªôt l√∫c r·ªìi th·ª≠ l·∫°i")
                    return None
            elif response.status_code >= 500:
                log_error(f"L·ªói server (5xx): {response.status_code}")
                if attempt < max_retries - 1:
                    log_warning("Server Google Labs c√≥ th·ªÉ ƒëang g·∫∑p s·ª± c·ªë, th·ª≠ l·∫°i...")
                    continue
                else:
                    log_error("Server Google Labs c√≥ th·ªÉ ƒëang g·∫∑p s·ª± c·ªë")
                    return None
            else:
                log_error(f"L·ªói HTTP kh√¥ng x√°c ƒë·ªãnh: {response.status_code}")
                log_error(f"Response text: {response.text}")
                if attempt < max_retries - 1:
                    log_warning(f"S·∫Ω th·ª≠ l·∫°i sau {2 * (attempt + 1)} gi√¢y...")
                    continue
                return None
        except requests.exceptions.Timeout:
            spinner.stop()
            log_error("Timeout khi t·∫°o ·∫£nh - c√≥ th·ªÉ prompt qu√° ph·ª©c t·∫°p")
            if attempt < max_retries - 1:
                log_warning(f"S·∫Ω th·ª≠ l·∫°i sau {2 * (attempt + 1)} gi√¢y...")
                continue
            return None
        except Exception as e:
            spinner.stop()
            log_error(f"L·ªói khi t·∫°o ·∫£nh: {e}")
            if attempt < max_retries - 1:
                log_warning(f"S·∫Ω th·ª≠ l·∫°i sau {2 * (attempt + 1)} gi√¢y...")
                continue
            return None
    
    log_error(f"ƒê√£ th·ª≠ {max_retries} l·∫ßn nh∆∞ng v·∫´n th·∫•t b·∫°i")
    return None

def download_image(image_url, filename):
    """T·∫£i xu·ªëng ·∫£nh"""
    try:
        # S·ª≠ d·ª•ng proxy n·∫øu c√≥
        proxies = browser_sim.proxy_config if browser_sim.proxy_config else None
        response = requests.get(image_url, proxies=proxies)
        if response.status_code == 200:
            with open(filename, 'wb') as f:
                f.write(response.content)
            log_success(f"ƒê√£ t·∫£i xu·ªëng: {filename}")
            return True
    except Exception as e:
        log_error(f"L·ªói khi t·∫£i xu·ªëng ·∫£nh {filename}: {e}")
    return False

def save_base64_image(base64_data, filename, output_folder="./"):
    """L∆∞u ·∫£nh t·ª´ base64 v√†o folder ƒë∆∞·ª£c ch·ªâ ƒë·ªãnh"""
    full_path = os.path.join(output_folder, filename)
    
    try:
        # Lo·∫°i b·ªè prefix data:image/jpeg;base64, n·∫øu c√≥
        if ',' in base64_data:
            base64_data = base64_data.split(',')[1]
        
        image_data = base64.b64decode(base64_data)
        
        with open(full_path, 'wb') as f:
            f.write(image_data)
        
        return True
    except Exception as e:
        log_error(f"L·ªói khi l∆∞u ·∫£nh {full_path}: {e}")
        return False

def upload_image_to_google_labs(cookie, image_path, caption="A hyperrealistic digital illustration depicts a shiny, chrome-like mouse character, standing confidently in a martial arts gi against a subtly rendered, dark background of what appears to be an arena. The character, positioned centrally in the frame, faces forward with a slight tilt of its head to the right. Its body is composed of a highly reflective, polished silver material, giving it a metallic, almost liquid sheen.\n\nThe mouse has large, round ears that match its reflective silver body. Its face is characterized by large, expressive eyes with black pupils surrounded by a thin white iris, and a faint, thin black eyebrow line above each eye. A small, dark triangular nose sits above a tiny, closed mouth. Whiskers, depicted as thin black lines, extend from its cheeks. The overall expression of the mouse is one of determination or seriousness.\n\nIt wears a dark, possibly black or very dark gray, martial arts gi. The gi consists of a wrap-around top with a V-neck opening and wide sleeves, secured at the waist by a tied belt with a knot at the front. The fabric of the gi has visible texture, with distinct lines and shading suggesting folds and creases, giving it a somewhat sketch-like or illustrated appearance in contrast to the smooth, reflective quality of the mouse's skin. The gi extends down to just above its feet. The mouse's feet are clad in simple, low-top white sneakers with dark soles, contrasting with the dark gi.\n\nThe background is dark and desaturated, creating a stark contrast with the shiny character. It suggests the interior of an arena or training dojo, with a circular, slightly elevated platform visible in the foreground where the mouse stands. The background features blurred architectural elements, possibly seating or walls, rendered in shades of dark gray and black. A faint \"SU\" logo, stylized in white, is visible in the upper right corner of the image. The lighting appears to come from the front and slightly above, accentuating the metallic sheen of the mouse and casting subtle shadows."):
    """Upload ·∫£nh l√™n Google Labs API"""
    url = "https://labs.google/fx/api/trpc/backbone.uploadImage"
    
    headers = browser_sim.get_api_headers(cookie=cookie)
    
    # ƒê·ªçc ·∫£nh v√† chuy·ªÉn th√†nh base64
    try:
        with open(image_path, 'rb') as image_file:
            image_data = base64.b64encode(image_file.read()).decode('utf-8')
            # Th√™m prefix data:image/jpeg;base64,
            base64_string = f"data:image/jpeg;base64,{image_data}"
    except Exception as e:
        log_error(f"L·ªói khi ƒë·ªçc file ·∫£nh {image_path}: {e}")
        return None
    
    # T·∫°o UUID cho workflowId v√† sessionId
    workflow_id = str(uuid.uuid4())
    session_id = f";{uuid.uuid4().int}"
    
    payload = {
        "json": {
            "clientContext": {
                "workflowId": workflow_id,
                "sessionId": session_id
            },
            "uploadMediaInput": {
                "mediaCategory": "MEDIA_CATEGORY_SUBJECT",
                "rawBytes": base64_string,
                "caption": caption
            }
        }
    }
    
    # Hi·ªÉn th·ªã loading spinner
    spinner = LoadingSpinner("ƒêang upload ·∫£nh l√™n Google Labs...", Fore.CYAN)
    spinner.start()
    
    try:
        response = browser_sim.make_request("POST", url, headers=headers, json=payload, timeout=60)
        spinner.stop()
        
        if response and response.status_code == 200:
            result = response.json()
            if 'result' in result and 'data' in result['result']:
                upload_data = result['result']['data']['json']['result']
                log_success("Upload ·∫£nh th√†nh c√¥ng!")
                return {
                    'caption': caption,
                    'uploadMediaGenerationId': upload_data['uploadMediaGenerationId'],
                    'workflowId': workflow_id,
                    'sessionId': session_id
                }
        else:
            if response:
                log_error(f"L·ªói khi upload ·∫£nh: {response.status_code}")
                log_error(response.text)
            return None
    except requests.exceptions.Timeout:
        spinner.stop()
        log_error("Timeout khi upload ·∫£nh")
        return None
    except Exception as e:
        spinner.stop()
        log_error(f"L·ªói khi upload ·∫£nh: {e}")
        return None

def generate_image_from_multiple_images(access_token, upload_data_list, user_instruction, seed, image_model="IMAGEN_3_5", aspect_ratio="IMAGE_ASPECT_RATIO_LANDSCAPE"):
    """T·∫°o ·∫£nh t·ª´ nhi·ªÅu ·∫£nh ƒë√£ upload"""
    url = "https://aisandbox-pa.googleapis.com/v1/whisk:runImageRecipe"
    
    headers = browser_sim.get_api_headers(access_token=access_token)
    
    # T·∫°o recipeMediaInputs t·ª´ upload_data_list
    recipe_media_inputs = []
    for upload_data in upload_data_list:
        recipe_media_inputs.append({
            "caption": upload_data.get('caption', ''),
            "mediaInput": {
                "mediaCategory": upload_data['mediaCategory'],
                "mediaGenerationId": upload_data['uploadMediaGenerationId']
            }
        })
    
    payload = {
        "clientContext": {
            "workflowId": upload_data_list[0]['workflowId'] if upload_data_list else "",
            "tool": "BACKBONE",
            "sessionId": upload_data_list[0]['sessionId'] if upload_data_list else ""
        },
        "seed": seed,
        "imageModelSettings": {
            "imageModel": image_model,
            "aspectRatio": aspect_ratio
        },
        "userInstruction": user_instruction,
        "recipeMediaInputs": recipe_media_inputs
    }
    
    try:
        response = requests.post(url, headers=headers, json=payload)
        response.raise_for_status()
        return response.json()
    except Exception as e:
        log_error(f"L·ªói khi t·∫°o ·∫£nh t·ª´ nhi·ªÅu ·∫£nh: {e}")
        return None

def generate_image_from_image(access_token, upload_data, user_instruction, seed, image_model="IMAGEN_3_5", aspect_ratio="IMAGE_ASPECT_RATIO_LANDSCAPE"):
    """T·∫°o ·∫£nh t·ª´ ·∫£nh ƒë√£ upload"""
    url = "https://aisandbox-pa.googleapis.com/v1/whisk:runImageRecipe"
    
    headers = browser_sim.get_api_headers(access_token=access_token)
    
    payload = {
        "clientContext": {
            "workflowId": upload_data['workflowId'],
            "tool": "BACKBONE",
            "sessionId": upload_data['sessionId']
        },
        "seed": seed,
        "imageModelSettings": {
            "imageModel": image_model,
            "aspectRatio": aspect_ratio
        },
        "userInstruction": user_instruction,
        "recipeMediaInputs": [
            {
                "caption": upload_data.get('caption', ''),
                "mediaInput": {
                    "mediaCategory": "MEDIA_CATEGORY_SUBJECT",
                    "mediaGenerationId": upload_data['uploadMediaGenerationId']
                }
            },
            {
                "caption": upload_data.get('caption', ''),
                "mediaInput": {
                    "mediaCategory": "MEDIA_CATEGORY_SCENE",
                    "mediaGenerationId": upload_data['uploadMediaGenerationId']
                }
            },
            {
                "caption": upload_data.get('caption', ''),
                "mediaInput": {
                    "mediaCategory": "MEDIA_CATEGORY_STYLE",
                    "mediaGenerationId": upload_data['uploadMediaGenerationId']
                }
            }
        ]
    }
    
    
    # Hi·ªÉn th·ªã loading spinner
    spinner = LoadingSpinner("ƒêang t·∫°o ·∫£nh t·ª´ ·∫£nh v·ªõi AI...", Fore.MAGENTA)
    spinner.start()
    
    try:
        response = browser_sim.make_request("POST", url, headers=headers, json=payload, timeout=60)
        spinner.stop()
        
        if response and response.status_code == 200:
            return response.json()
        else:
            if response:
                log_error(f"L·ªói khi t·∫°o ·∫£nh t·ª´ ·∫£nh: {response.status_code}")
                log_error(response.text)
            return None
    except requests.exceptions.Timeout:
        spinner.stop()
        log_error("Timeout khi t·∫°o ·∫£nh t·ª´ ·∫£nh")
        return None
    except Exception as e:
        spinner.stop()
        log_error(f"L·ªói khi t·∫°o ·∫£nh t·ª´ ·∫£nh: {e}")
        return None

def sanitize_filename(stt_value, prompt_text, max_prompt_length=80):
    """T·∫°o t√™n file an to√†n cho Windows: STT_PROMPT.jpg"""
    invalid_chars = '\\/:*?"<>|'
    safe = ''.join(
        (ch if (ch.isalnum() or ch in (' ', '-', '_')) and ch not in invalid_chars else '_')
        for ch in str(prompt_text)
    )
    safe = ' '.join(safe.split())  # chu·∫©n h√≥a kho·∫£ng tr·∫Øng
    safe = safe.strip(' .')  # b·ªè d·∫•u ch·∫•m ho·∫∑c space ·ªü cu·ªëi
    if len(safe) > max_prompt_length:
        safe = safe[:max_prompt_length].rstrip()
    if not safe:
        safe = 'image'
    return f"{stt_value}_{safe}.jpg"





